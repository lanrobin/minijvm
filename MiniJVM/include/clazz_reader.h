#ifndef __JVM_CLASS_READER__
#define __JVM_CLASS_READER__

#include <iostream>
#include <vector>
#include <map>
#include "platform.h"
#include "base_type.h"

using namespace std;

/**
这个文件主要是解析class文件，参照  https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html
*/

const u2 MAX_SUPPORTED_CLASS_FILE_VERSION = 58;
const u2 MIN_SUPPORTED_CLASS_FILE_VERSION = 45;



/// field access flag
const u2 FIELD_ACC_PUBLIC = 0x0001; //Declared public; may be accessed from outside its package.
const u2 FIELD_ACC_FINAL = 0x0010; //Declared final; no subclasses allowed.
const u2 FIELD_ACC_SUPER = 0x0020; //Treat superclass methods specially when invoked by the invokespecial instruction.
const u2 FIELD_ACC_INTERFACE = 0x0200; //Is an interface, not a class.
const u2 FIELD_ACC_ABSTRACT = 0x0400; //Declared abstract; must not be instantiated.
const u2 FIELD_ACC_SYNTHETIC = 0x1000; //Declared synthetic; not present in the source code.
const u2 FIELD_ACC_ANNOTATION = 0x2000; //Declared as an annotation type.
const u2 FIELD_ACC_ENUM = 0x4000; //Declared as an enum type.
const u2 FIELD_ACC_MODULE = 0x8000; //Is a module, not a class or interface.

enum ConstantPoolType : u1 {
    Utf8 = 1, // class file version 45.3, since Java:1.0.2
    Integer = 3, // class file version 45.3, since Java:1.0.2
    Float = 4, // class file version 45.3, since Java:1.0.2
    Long = 5, // class file version 45.3, since Java:1.0.2
    Double = 6, // class file version 45.3, since Java:1.0.2
    Class = 7, // class file version 45.3, since Java:1.0.2
    String = 8, // class file version 45.3, since Java:1.0.2
    Fieldref = 9, // class file version 45.3, since Java:1.0.2
    Methodref = 10, // class file version 45.3, since Java:1.0.2
    InterfaceMethodref = 11, // class file version 45.3, since Java:1.0.2
    NameAndType = 12, // class file version 45.3, since Java:1.0.2
    MethodHandle = 15, // class file version 51, since Java:7
    MethodType = 16, // class file version 51, since Java:7
    Dynamic = 17, // class file version 55, since Java:11
    InvokeDynamic = 18, // class file version 51, since Java:7
    Module = 19, // class file version 53, since Java:9
    Package = 20, // class file version 53, since Java:9
};

const u2 METHOD_ACC_PUBLIC = 0x0001; // Declared public; may be accessed from outside its package.
const u2 METHOD_ACC_PRIVATE = 0x0002; // Declared private; accessible only within the defining class and other classes belonging to the same nest (§5.4.4).
const u2 METHOD_ACC_PROTECTED = 0x0004; // Declared protected; may be accessed within subclasses.
const u2 METHOD_ACC_STATIC = 0x0008; // Declared static.
const u2 METHOD_ACC_FINAL = 0x0010; // Declared final; must not be overridden (§5.4.5).
const u2 METHOD_ACC_SYNCHRONIZED = 0x0020; // Declared synchronized; invocation is wrapped by a monitor use.
const u2 METHOD_ACC_BRIDGE = 0x0040; // A bridge method, generated by the compiler.
const u2 METHOD_ACC_VARARGS = 0x0080; // Declared with variable number of arguments.
const u2 METHOD_ACC_NATIVE = 0x0100; // Declared native; implemented in a language other than the Java programming language.
const u2 METHOD_ACC_ABSTRACT = 0x0400; // Declared abstract; no implementation is provided.
const u2 METHOD_ACC_STRICT = 0x0800; // Declared strictfp; floating-point mode is FP-strict.
const u2 METHOD_ACC_SYNTHETIC = 0x1000; // Declared synthetic; not present in the source code.


const u2 NESTED_CLASS_ACC_PUBLIC = 0x0001; // Marked or implicitly public in source.
const u2 NESTED_CLASS_ACC_PRIVATE = 0x0002; // Marked private in source.
const u2 NESTED_CLASS_ACC_PROTECTED = 0x0004; // Marked protected in source.
const u2 NESTED_CLASS_ACC_STATIC = 0x0008; // Marked or implicitly static in source.
const u2 NESTED_CLASS_ACC_FINAL = 0x0010; // Marked or implicitly final in source.
const u2 NESTED_CLASS_ACC_INTERFACE = 0x0200; // Was an interface in source.
const u2 NESTED_CLASS_ACC_ABSTRACT = 0x0400; // Marked or implicitly abstract in source.
const u2 NESTED_CLASS_ACC_SYNTHETIC = 0x1000; // Declared synthetic; not present in the source code.
const u2 NESTED_CLASS_ACC_ANNOTATION = 0x2000; // Declared as an annotation type.
const u2 NESTED_CLASS_ACC_ENUM = 0x4000; // Declared as an enum type.


u1 peaku1(istream& is);
u2 peaku2(istream& is);
u4 peaku4(istream& is);

u1 readu1(istream& is);
u2 readu2(istream& is);
u4 readu4(istream& is);

u4 read_u1_vector(vector<u1>& v, istream& is, u4 count);
u4 read_u2_vector(vector<u2>& v, istream& is, u4 count);


//常量区定义
struct CONSTANT_Info {
    u1 tag;
    CONSTANT_Info(istream& is) {
        tag = readu1(is);
    }
    CONSTANT_Info() {}
    
    //这个是需要的，否则会报 error C2683: 'dynamic_cast': 'CONSTANT_Info' is not a polymorphic type
    virtual ~CONSTANT_Info() {};
};

struct CONSTANT_Class_info : CONSTANT_Info {
    u2 name_index;
    CONSTANT_Class_info(istream& is) :CONSTANT_Info(is) {
        name_index = readu2(is);
    }
};

struct CONSTANT_Fieldref_info : CONSTANT_Info {
    u2 class_index;
    u2 name_and_type_index;

    CONSTANT_Fieldref_info(istream& is) :CONSTANT_Info(is) {
        class_index = readu2(is);
        name_and_type_index = readu2(is);
    }
};

struct CONSTANT_Methodref_info : CONSTANT_Info {
    u2 class_index;
    u2 name_and_type_index;

    CONSTANT_Methodref_info(istream& is) :CONSTANT_Info(is) {
        class_index = readu2(is);
        name_and_type_index = readu2(is);
    }
};

struct CONSTANT_InterfaceMethodref_info : CONSTANT_Info {
    u2 class_index;
    u2 name_and_type_index;

    CONSTANT_InterfaceMethodref_info(istream& is) :CONSTANT_Info(is) {
        class_index = readu2(is);
        name_and_type_index = readu2(is);
    }
};

struct CONSTANT_String_info : CONSTANT_Info {
    u2 string_index;
    CONSTANT_String_info(istream& is) :CONSTANT_Info(is) {
        string_index = readu2(is);
    }
};

struct CONSTANT_Integer_info : CONSTANT_Info {
    u4 bytes;
    CONSTANT_Integer_info(istream& is) :CONSTANT_Info(is) {
        bytes = readu4(is);
    }
};

struct CONSTANT_Float_info : CONSTANT_Info {
    u4 bytes;
    CONSTANT_Float_info(istream& is) :CONSTANT_Info(is) {
        bytes = readu4(is);
    }
};

struct  CONSTANT_Long_info : CONSTANT_Info {
    u4 high_bytes;
    u4 low_bytes;

    CONSTANT_Long_info(istream& is) :CONSTANT_Info(is) {
        high_bytes = readu4(is);
        low_bytes = readu4(is);
    }
};

struct  CONSTANT_Double_info : CONSTANT_Info {
    u4 high_bytes;
    u4 low_bytes;

    CONSTANT_Double_info(istream& is) :CONSTANT_Info(is) {
        high_bytes = readu4(is);
        low_bytes = readu4(is);
    }
};

struct CONSTANT_NameAndType_info : CONSTANT_Info {
    u2 name_index;
    u2 descriptor_index;
    CONSTANT_NameAndType_info(istream& is) :CONSTANT_Info(is) {
        name_index = readu2(is);
        descriptor_index = readu2(is);
    }
};

struct CONSTANT_Utf8_info : CONSTANT_Info {
    u2 length;
    vector<u1> bytes;

    CONSTANT_Utf8_info(istream& is) :CONSTANT_Info(is) {
        length = readu2(is);
        read_u1_vector(bytes, is, length);
    }

    wstring toUTF8String();

private:
    wstring utf8String;
};

struct CONSTANT_MethodHandle_info : CONSTANT_Info {
    u1 reference_kind;
    u2 reference_index;
    CONSTANT_MethodHandle_info(istream& is) :CONSTANT_Info(is) {
        reference_kind = readu1(is);
        reference_index = readu2(is);
    }
};

struct CONSTANT_MethodType_info : CONSTANT_Info {
    u2 descriptor_index;

    CONSTANT_MethodType_info(istream& is) :CONSTANT_Info(is) {
        descriptor_index = readu2(is);
    }
};

struct CONSTANT_Dynamic_info : CONSTANT_Info {
    u2 bootstrap_method_attr_index;
    u2 name_and_type_index;
    CONSTANT_Dynamic_info(istream& is) :CONSTANT_Info(is) {
        bootstrap_method_attr_index = readu2(is);
        name_and_type_index = readu2(is);
    }
};

struct CONSTANT_InvokeDynamic_info : CONSTANT_Info {
    u2 bootstrap_method_attr_index;
    u2 name_and_type_index;
    CONSTANT_InvokeDynamic_info(istream& is) :CONSTANT_Info(is) {
        bootstrap_method_attr_index = readu2(is);
        name_and_type_index = readu2(is);
    }
};

struct CONSTANT_Module_info : CONSTANT_Info {
    u2 name_index;
    CONSTANT_Module_info(istream& is) :CONSTANT_Info(is) {
        name_index = readu2(is);
    }
};

struct CONSTANT_Package_info : CONSTANT_Info {
    u2 name_index;
    CONSTANT_Package_info(istream& is) :CONSTANT_Info(is) {
        name_index = readu2(is);
    }
};

/*
这个类应该是用不到，只是为了Long和Double的类型占位用的。
*/
struct CONSTANT_LargeNumberContinuous_info :CONSTANT_Info {

};

/*
第一个(Index为0的slot不用，用这个占住。)
*/
struct CONSTANT_Dummy_info :CONSTANT_Info {

};
//常量区定义结束。


// Attribute区

struct Attribute_Info {
    u2 attribute_name_index;
    u4 attribute_length;

    //vector<u1> info;
    Attribute_Info(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) :constantPool(cp) {
        attribute_name_index = readu2(is);
        attribute_length = readu4(is);
        //read_u1_vector(info, is, attribute_length);
        //shared_ptr<CONSTANT_Utf8_info> entry = std::dynamic_pointer_cast<CONSTANT_Utf8_info>(cp[attribute_name_index]);
    }

    wstring getAttributeName() {
        if (name.empty()) {
            name = std::dynamic_pointer_cast<CONSTANT_Utf8_info>(constantPool[attribute_name_index])->toUTF8String();
        }
        return name;
    }

private:
    wstring name;

protected:
    const vector<shared_ptr<CONSTANT_Info>> & constantPool;
    wstring getConstantPoolUTF8Wstring(u2 index) {
        return std::dynamic_pointer_cast<CONSTANT_Utf8_info>(constantPool[index])->toUTF8String();
    }
};
/*
读取Attribute_Info
*/
shared_ptr<Attribute_Info> readAttributeInfo(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp);

struct ConstantValue_attribute :Attribute_Info {
    u2 constantvalue_index;
    ConstantValue_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp)
    {
        constantvalue_index = readu2(is);
    }
};

struct Code_attribute : Attribute_Info {

    struct ExceptionTable {
        u2 start_pc;
        u2 end_pc;
        u2 handler_pc;
        u2 catch_type;
        ExceptionTable(istream& is) {
            start_pc = readu2(is);
            end_pc = readu2(is);
            handler_pc = readu2(is);
            catch_type = readu2(is);
        }
    };

    u2 max_stack;
    u2 max_locals;
    u4 code_length;
    vector<u1> code;
    u2 exception_table_length;
    vector<shared_ptr<ExceptionTable>> exception_table;
    u2 attributes_count;
    vector<shared_ptr<Attribute_Info>> attributes;

    Code_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        max_stack = readu2(is);
        max_locals = readu2(is);
        code_length = readu4(is);
        read_u1_vector(code, is, code_length);
        attributes_count = readu2(is);
        for (u2 i = 0; i < attributes_count; i++) {
            attributes.push_back(readAttributeInfo(is, cp));
        }
        exception_table_length = readu2(is);
        for (u2 i = 0; i < exception_table_length; i++) {
            exception_table.push_back(make_shared< ExceptionTable>(is));
        }
        attributes_count = readu2(is);
        for (u2 i = 0; i < attributes_count; i++) {
            attributes.push_back(readAttributeInfo(is, cp));
        }
    }
};

struct StackMapTable_attribute : Attribute_Info {

    /*
    Verification definition begin
    */
    enum StackMapTableVerificationItemType : u1 {
        ITEM_Top = 0,
        ITEM_Integer = 1,
        ITEM_Float = 2,
        ITEM_Double = 3,
        ITEM_Long = 4,
        ITEM_Null = 5,
        ITEM_UninitializedThis = 6,
        ITEM_Object = 7,
        ITEM_Uninitialized = 8
    };
    
    struct verification_type_info {
        u1 tag;
        verification_type_info(istream& is) {
            tag = readu1(is);
        }
    };
    struct Top_variable_info : verification_type_info {
        Top_variable_info(istream& is) : verification_type_info(is) {}
    };
    struct Integer_variable_info : verification_type_info {
        Integer_variable_info(istream& is) : verification_type_info(is) {}
    };
    struct Float_variable_info : verification_type_info {
        Float_variable_info(istream& is) : verification_type_info(is) {}
    };
    struct Null_variable_info : verification_type_info {
        Null_variable_info(istream& is) : verification_type_info(is) {}
    };
    struct UninitializedThis_variable_info : verification_type_info {
        UninitializedThis_variable_info(istream& is) : verification_type_info(is) {}
    };
    struct Object_variable_info : verification_type_info {
        u2 cpool_index;
        Object_variable_info(istream& is) : verification_type_info(is) {
            cpool_index = readu2(is);
        }
    };
    struct Uninitialized_variable_info : verification_type_info {
        u2 offset;
        Uninitialized_variable_info(istream& is) : verification_type_info(is) {
            offset = readu2(is);
        }
    };
    struct Long_variable_info : verification_type_info {
        Long_variable_info(istream& is) : verification_type_info(is) {}
    };
    struct Double_variable_info : verification_type_info {
        Double_variable_info(istream& is) : verification_type_info(is) {}
    };
    /*
    Verification definition end
    */

    struct stack_map_frame {
        u1 frame_type;
        stack_map_frame(istream& is) {
            frame_type = readu1(is);
        }
    protected:
        void readVerificaitonTypes(vector< shared_ptr<verification_type_info>>& vec, istream& is, u2 numbers) {
            for (u2 i = 0; i < numbers; i++) {
                vec.push_back(readVerificationTypeInfo(is));
            }
        }
    };

    struct same_frame :stack_map_frame {
        same_frame(istream& is) : stack_map_frame(is) {}
    };
    struct same_locals_1_stack_item_frame :stack_map_frame {
        vector< shared_ptr<verification_type_info>> stack; // 只有一个
        same_locals_1_stack_item_frame(istream& is) : stack_map_frame(is) {
            readVerificaitonTypes(stack, is, 1);
        }
    };
    struct same_locals_1_stack_item_frame_extended :stack_map_frame {
        u2 offset_delta;
        vector< shared_ptr<verification_type_info>> stack; //只有一个
        same_locals_1_stack_item_frame_extended(istream& is) : stack_map_frame(is) {
            offset_delta = readu2(is);
            readVerificaitonTypes(stack, is, 1);
        }
    };
    struct chop_frame :stack_map_frame {
        u2 offset_delta;
        chop_frame(istream& is) : stack_map_frame(is) {
            offset_delta = readu2(is);
        }
    };
    struct same_frame_extended :stack_map_frame {
        u2 offset_delta;
        same_frame_extended(istream& is) : stack_map_frame(is) {
            offset_delta = readu2(is);
        }
    };
    struct append_frame :stack_map_frame {
        vector< shared_ptr<verification_type_info>> locals;
        u2 offset_delta;
        append_frame(istream& is) : stack_map_frame(is) {
            offset_delta = readu2(is);
        }
    };

    struct full_frame :stack_map_frame {
        u2 offset_delta;
        u2 number_of_locals;
        vector<shared_ptr<verification_type_info>> locals;
        u2 number_of_stack_items;
        vector<shared_ptr<verification_type_info>> stack;
        full_frame(istream& is) : stack_map_frame(is) {
            offset_delta = readu2(is);
            number_of_locals = readu2(is);
            readVerificaitonTypes(locals, is, number_of_locals);
            number_of_stack_items = readu2(is);
            readVerificaitonTypes(stack, is, number_of_stack_items);
        }
    };

    u2 attribute_name_index;
    u4 attribute_length;
    u2 number_of_entries;
    vector<shared_ptr<stack_map_frame>> entries;

    StackMapTable_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp)
    {
        number_of_entries = readu2(is);
        for (u2 i = 0; i < number_of_entries; i++) {
            entries.push_back(readStackMapFrame(is));
        }
    }
private:
    static shared_ptr<verification_type_info> readVerificationTypeInfo(istream& is);
    static shared_ptr<stack_map_frame> readStackMapFrame(istream& is);
};

struct Exceptions_attribute :Attribute_Info {
    u2 number_of_exceptions;
    vector<u2> exception_index_table;
    Exceptions_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        number_of_exceptions = readu2(is);
        read_u2_vector(exception_index_table, is, number_of_exceptions);
    }
};

struct InnerClasses_attribute : Attribute_Info {
    struct InnerClass {
        u2 inner_class_info_index;
        u2 outer_class_info_index;
        u2 inner_name_index;
        u2 inner_class_access_flags;
        InnerClass(istream& is) {
            inner_class_info_index = readu2(is);
            outer_class_info_index = readu2(is);
            inner_name_index = readu2(is);
            inner_class_access_flags = readu2(is);
        }
    };

    u2 number_of_classes;
    vector<shared_ptr< InnerClass>> classes;

    InnerClasses_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        number_of_classes = readu2(is);
        for (u2 i = 0; i < number_of_classes; i++) {
            classes.push_back(make_shared< InnerClass>(is));
        }
    }
};

struct EnclosingMethod_attribute : Attribute_Info {
    u2 class_index;
    u2 method_index;

    EnclosingMethod_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        class_index = readu2(is);
        method_index = readu2(is);
    }
};

struct Synthetic_attribute : Attribute_Info {
    Synthetic_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
    }
};

struct Signature_attribute : Attribute_Info {
    u2 signature_index;
    Signature_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        signature_index = readu2(is);
    }
};

struct SourceFile_attribute : Attribute_Info {
    u2 sourcefile_index;
    SourceFile_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        sourcefile_index = readu2(is);
    }
};

struct SourceDebugExtension_attribute : Attribute_Info {
    vector<u1> debug_extension;
    SourceDebugExtension_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        read_u1_vector(debug_extension, is, attribute_length);
    }
};

struct LineNumberTable_attribute : Attribute_Info {
    struct LineNumberTable {
        u2 start_pc;
        u2 line_number;
        LineNumberTable(istream& is) {
            start_pc = readu2(is);
            line_number = readu2(is);
        }
    };
    u2 line_number_table_length;
    vector<shared_ptr<LineNumberTable>> line_number_table;
    LineNumberTable_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        line_number_table_length = readu2(is);
        for (u2 i = 0; i < line_number_table_length; i++) {
            line_number_table.push_back(make_shared< LineNumberTable>(is));
        }
    }
};

struct LocalVariableTable_attribute : Attribute_Info {
    struct LocalVariableTable {
        u2 start_pc;
        u2 length;
        u2 name_index;
        u2 descriptor_index;
        u2 index;
        LocalVariableTable(istream& is)
        {
            start_pc = readu2(is);
            length = readu2(is);
            name_index = readu2(is);
            descriptor_index = readu2(is);
            index = readu2(is);
        }
    };
    u2 local_variable_table_length;
    vector<shared_ptr< LocalVariableTable>> local_variable_table;
    LocalVariableTable_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        local_variable_table_length = readu2(is);
        for (u2 i = 0; i < local_variable_table_length; i++) {
            local_variable_table.push_back(make_shared<LocalVariableTable>(is));
        }
    }
};

struct LocalVariableTypeTable_attribute : Attribute_Info {
    struct LocalVariableTypeTable {
        u2 start_pc;
        u2 length;
        u2 name_index;
        u2 signature_index;
        u2 index;
        LocalVariableTypeTable(istream& is)
        {
            start_pc = readu2(is);
            length = readu2(is);
            name_index = readu2(is);
            signature_index = readu2(is);
            index = readu2(is);
        }
    };
    u2 local_variable_type_table_length;
    vector<shared_ptr< LocalVariableTypeTable>> local_variable_type_table;
    LocalVariableTypeTable_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>> & cp) : Attribute_Info(is, cp) {
        local_variable_type_table_length = readu2(is);
        for (u2 i = 0; i < local_variable_type_table_length; i++) {
            local_variable_type_table.push_back(make_shared<LocalVariableTypeTable>(is));
        }
    }
};

struct Deprecated_attribute : Attribute_Info {
    Deprecated_attribute(istream& is, const vector<shared_ptr<CONSTANT_Info>>& cp) : Attribute_Info(is, cp) {
    }
};

struct Unknown_attribute :Attribute_Info {
    vector<u1> info;
};

//字段区定义
struct Field_Info {
    u2 access_flags;
    u2 name_index;
    u2 descriptor_index;
    u2 attributes_count;
    vector<shared_ptr<Attribute_Info>> attributes;
    Field_Info(istream& is, const vector<shared_ptr<CONSTANT_Info>>& cp) {
        access_flags = readu2(is);
        name_index = readu2(is);
        descriptor_index = readu2(is);
        attributes_count = readu2(is);
        for (int i = 0; i < attributes_count; i++) {
            attributes.push_back(make_shared<Attribute_Info>(is, cp));
        }
    }
};
//字段区定义结束


//方法区

struct Method_Info {
    u2 access_flags;
    u2 name_index;
    u2 descriptor_index;
    u2 attributes_count;
    vector<shared_ptr<Attribute_Info>> attributes;
    Method_Info(istream& is, const vector<shared_ptr<CONSTANT_Info>>& cp) {
        access_flags = readu2(is);
        name_index = readu2(is);
        descriptor_index = readu2(is);
        attributes_count = readu2(is);
        for (int i = 0; i < attributes_count; i++) {
            attributes.push_back(make_shared<Attribute_Info>(is, cp));
        }
    }
};

//方法区结束

/*
定义一个.class文件的结构体。
*/
struct ClassFile {
    u4 magic;
    u2 minor_version;
    u2 major_version;
    u2 constant_pool_count;
    vector<shared_ptr<CONSTANT_Info>> constant_pool;
    u2 access_flags;
    u2 this_class;
    u2 super_class;
    u2 interfaces_count;
    vector<u2> interfaces;
    u2 fields_count;
    vector<shared_ptr<Field_Info>> fields;
    u2 methods_count;
    vector<shared_ptr<Method_Info>> methods;
    u2 attributes_count;
    vector<shared_ptr<Attribute_Info>> attributes;

    ClassFile(istream& is);

    bool checkClassFile();
//private:
    //map<ConstantPoolType, decltype> contants_pool_map;

private:
    void readConstantPools(istream& is);
    void readInterfaces(istream& is);
    void readFieldInfos(istream& is);
    void readMethodInfos(istream& is);
    void readAttributes(istream& is);
};


#endif // !__JAVA_CLASS__